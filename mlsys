#!/usr/bin/env python3
"""
🌟 Welcome to your new analysis project! 🌟

Like a seed that grows into a mighty tree,
Your project starts small but dreams free.
With data as soil and code as light,
Watch your insights bloom bright!

Stability in structure, growth in scope,
Consistency in process, endless hope.
"""

import sys
import subprocess
import shutil
from pathlib import Path
import os


def ensure_dependencies():
    """Ensure required dependencies are installed in a bootstrap virtual environment."""
    required_packages = ["typer[all]", "rich"]

    # Create bootstrap venv path
    bootstrap_venv = Path.home() / ".mlsys_bootstrap_venv"
    python_exe = bootstrap_venv / "bin" / "python"

    # Check if we're already running from the bootstrap environment
    if str(bootstrap_venv) in sys.executable:
        # We're already in the bootstrap environment, dependencies should be available
        return

    # Check if bootstrap venv exists and has our dependencies
    if bootstrap_venv.exists() and python_exe.exists():
        try:
            # Test if dependencies are available in the bootstrap venv
            result = subprocess.run(
                [
                    str(python_exe),
                    "-c",
                    'import typer, rich; print("Dependencies available")',
                ],
                capture_output=True,
                text=True,
                timeout=10,
            )

            if result.returncode == 0:
                # Dependencies are available, re-exec with bootstrap python
                print("🔄 Using bootstrap environment...")
                os.execv(str(python_exe), [str(python_exe)] + sys.argv)
        except (subprocess.TimeoutExpired, Exception):
            pass

    # Need to create/update bootstrap environment
    print("🚀 Setting up bootstrap environment...")

    # Remove old bootstrap venv if it exists but is broken
    if bootstrap_venv.exists():
        shutil.rmtree(bootstrap_venv)

    try:
        # Create new bootstrap venv
        print("  📦 Creating virtual environment...")
        subprocess.check_call(
            [sys.executable, "-m", "venv", str(bootstrap_venv)],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

        # Install dependencies in bootstrap venv
        print("  🔧 Installing dependencies...")
        subprocess.check_call(
            [str(python_exe), "-m", "pip", "install", "--quiet"] + required_packages,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )

        print("✅ Bootstrap environment ready!")

        # Re-exec with bootstrap python
        print("🔄 Switching to bootstrap environment...")
        os.execv(str(python_exe), [str(python_exe)] + sys.argv)

    except subprocess.CalledProcessError as e:
        print(f"❌ Failed to set up bootstrap environment: {e}")
        print("Please ensure you have:")
        print("  - Python venv module available")
        print("  - Internet connection for package downloads")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
        sys.exit(1)


# Ensure dependencies before importing them
ensure_dependencies()

# Now we can safely import our dependencies
try:
    import tomllib  # Python 3.11+
except ImportError:
    import tomli as tomllib  # Fallback for older Python versions

import typer  # noqa: E402
from rich.console import Console  # noqa: E402
from rich.panel import Panel  # noqa: E402


def write_toml(data, file_path):
    """Simple TOML writer for our specific use case."""

    def format_value(value):
        """Format a value for TOML output."""
        if isinstance(value, str):
            return f'"{value}"'
        elif isinstance(value, bool):
            return str(value).lower()
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            if value and isinstance(value[0], dict):
                # Array of inline tables
                items = []
                for item in value:
                    pairs = []
                    for k, v in item.items():
                        pairs.append(f"{k} = {format_value(v)}")
                    items.append("{" + ", ".join(pairs) + "}")
                return "[" + ", ".join(items) + "]"
            else:
                # Simple array
                return "[" + ", ".join(format_value(item) for item in value) + "]"
        elif isinstance(value, dict):
            # Inline table
            pairs = []
            for k, v in value.items():
                if isinstance(v, dict):
                    # Nested dict - cannot be inline
                    return None  # Signal that this needs to be a section
                pairs.append(f"{k} = {format_value(v)}")
            return "{" + ", ".join(pairs) + "}"
        else:
            return str(value)

    with open(file_path, "w") as f:
        for section, content in data.items():
            if isinstance(content, dict):
                f.write(f"[{section}]\n")
                for key, value in content.items():
                    if isinstance(value, dict):
                        # Check if this can be an inline table
                        inline_value = format_value(value)
                        if inline_value is not None:
                            f.write(f"{key} = {inline_value}\n")
                        else:
                            # Need to create a subsection
                            f.write(f"\n[{section}.{key}]\n")
                            for subkey, subvalue in value.items():
                                formatted = format_value(subvalue)
                                if formatted is not None:
                                    f.write(f"{subkey} = {formatted}\n")
                                elif isinstance(subvalue, dict):
                                    # Another level of nesting
                                    f.write(f"\n[{section}.{key}.{subkey}]\n")
                                    for nested_key, nested_value in subvalue.items():
                                        f.write(
                                            f"{nested_key} = {format_value(nested_value)}\n"
                                        )
                    else:
                        formatted = format_value(value)
                        if formatted is not None:
                            f.write(f"{key} = {formatted}\n")
                f.write("\n")
            else:
                f.write(f"{section} = {format_value(content)}\n")


# --- Configuration ---
OLD_PROJECT_NAME_SNAKE = "analysis_template"
OLD_PROJECT_NAME_KEBAB = "analysis-template"
OLD_PROJECT_NAME_TITLE = "Analysis Template"

# --- CLI Application Setup ---
app = typer.Typer(
    help="A utility CLI for managing this project.",
    add_completion=False,
    no_args_is_help=True,
    invoke_without_command=True,
)
console = Console()


def to_snake_case(name: str) -> str:
    """Converts a string to snake_case."""
    return name.lower().replace("-", "_").replace(" ", "_")


def to_kebab_case(name: str) -> str:
    """Converts a string to kebab-case."""
    return name.lower().replace("_", "-").replace(" ", "-")


def to_title_case(name: str) -> str:
    """Converts a string to Title Case, handling hyphens and underscores."""
    return " ".join(word.capitalize() for word in name.replace("-", "_").split("_"))


@app.callback()
def main(
    new_name: str = typer.Argument(
        ...,
        help="The new name for the project (e.g., 'customer-churn-model').",
    ),
):
    """
    Initializes and renames the project template.
    """
    project_root = Path(__file__).parent.resolve()
    old_src_path = project_root / "src" / OLD_PROJECT_NAME_SNAKE

    # --- 1. Introduction ---
    story = (
        "You stand at the trailhead of a new analysis. Before you lies a well-marked path, a template forged "
        "from past journeys. This script is your guide, ready to shape this path into a unique trail for your specific quest. "
        "It will rename the trails, update the maps, and prepare your expedition for the discoveries that await."
    )

    haiku = """
[bold green]Solid foundation,[/bold green]
[bold green]New ideas now take root,[/bold green]
[bold green]Growth is assured here.[/bold green]
    """
    console.print(
        Panel(
            f"{story}\n\n{haiku}",
            title="Project Initialization",
            border_style="blue",
            expand=False,
        )
    )

    if not old_src_path.exists():
        console.print(
            f"\n[bold red]Error:[/bold red] Project already appears to be initialized. "
            f"The directory '[cyan]{old_src_path.name}[/cyan]' was not found."
        )
        raise typer.Exit(code=1)

    console.print(
        f"\n🚀 Starting initialization with project name: [bold cyan]{new_name}[/bold cyan]"
    )

    # --- 2. Derive New Names ---
    new_snake_case = to_snake_case(new_name)
    new_kebab_case = to_kebab_case(new_name)
    new_title_case = to_title_case(new_name)
    console.print(f"   - Package name: [green]{new_snake_case}[/green]")
    console.print(f"   - Repo name: [green]{new_kebab_case}[/green]")

    # --- 3. Rename Source Directory ---
    new_src_path = project_root / "src" / new_snake_case
    shutil.move(str(old_src_path), str(new_src_path))
    console.print(f"✅ Renamed source directory to [cyan]{new_src_path.name}[/cyan]")

    # --- 4. Update pyproject.toml ---
    pyproject_path = project_root / "pyproject.toml"
    if pyproject_path.exists():
        try:
            with open(pyproject_path, "rb") as f:
                data = tomllib.load(f)

            # Handle both Poetry and PEP 621 formats
            if "tool" in data and "poetry" in data["tool"]:
                # Poetry format
                data["tool"]["poetry"]["name"] = new_kebab_case

                # Update packages configuration if it exists
                if "packages" in data["tool"]["poetry"]:
                    for package in data["tool"]["poetry"]["packages"]:
                        if isinstance(package, dict) and "include" in package:
                            # Update the include field to use the new package name
                            if package["include"] == OLD_PROJECT_NAME_SNAKE:
                                package["include"] = new_snake_case

                console.print(
                    "✅ Updated [cyan]pyproject.toml[/cyan] (Poetry format) with new project name."
                )
            elif "project" in data:
                # PEP 621 format
                data["project"]["name"] = new_kebab_case
                console.print(
                    "✅ Updated [cyan]pyproject.toml[/cyan] (PEP 621 format) with new project name."
                )
            else:
                console.print(
                    "[bold red]Error:[/bold red] '[cyan]pyproject.toml[/cyan]' is missing both '\\[project]' and '\\[tool.poetry]' tables."
                )
                raise typer.Exit(code=1)

            # Update CLI script name in Poetry if it exists
            if (
                "tool" in data
                and "poetry" in data["tool"]
                and "scripts" in data["tool"]["poetry"]
            ):
                scripts = data["tool"]["poetry"]["scripts"]
                # If there's a script with the old name, rename it
                if OLD_PROJECT_NAME_SNAKE in scripts:
                    old_script_path = scripts[OLD_PROJECT_NAME_SNAKE]
                    # Update the script path to use new package name
                    new_script_path = old_script_path.replace(
                        OLD_PROJECT_NAME_SNAKE, new_snake_case
                    )
                    scripts[new_snake_case] = new_script_path
                    del scripts[OLD_PROJECT_NAME_SNAKE]

            # Update ruff's linter settings for the new package name (if present)
            if "tool" in data and "ruff" in data.get("tool", {}):
                if (
                    "lint" in data["tool"]["ruff"]
                    and "isort" in data["tool"]["ruff"]["lint"]
                ):
                    data["tool"]["ruff"]["lint"]["isort"]["known-first-party"] = [
                        new_snake_case
                    ]

            # Update isort settings for the new package name (if present as separate tool)
            if "tool" in data and "isort" in data["tool"]:
                if "known_first_party" in data["tool"]["isort"]:
                    # Handle both list and string formats
                    known_first_party = data["tool"]["isort"]["known_first_party"]
                    if isinstance(known_first_party, list):
                        data["tool"]["isort"]["known_first_party"] = [
                            new_snake_case if name == OLD_PROJECT_NAME_SNAKE else name
                            for name in known_first_party
                        ]
                    elif (
                        isinstance(known_first_party, str)
                        and known_first_party == OLD_PROJECT_NAME_SNAKE
                    ):
                        data["tool"]["isort"]["known_first_party"] = new_snake_case

            write_toml(data, pyproject_path)
        except Exception as e:
            console.print(f"[bold red]Error updating pyproject.toml:[/bold red] {e}")
            raise typer.Exit(code=1)

    # --- 5. Update Documentation Files ---
    docs_path = project_root / "docs"
    md_files = list(docs_path.rglob("*.md"))
    files_changed_count = 0
    for md_file in md_files:
        try:
            content = md_file.read_text(encoding="utf-8")
            if OLD_PROJECT_NAME_KEBAB in content or OLD_PROJECT_NAME_TITLE in content:
                content = content.replace(OLD_PROJECT_NAME_KEBAB, new_kebab_case)
                content = content.replace(OLD_PROJECT_NAME_TITLE, new_title_case)
                md_file.write_text(content, encoding="utf-8")
                files_changed_count += 1
        except Exception:
            pass
    console.print(f"✅ Scanned and updated {files_changed_count} documentation files.")

    # --- 6. Final Message ---
    console.print(
        Panel(
            "🎉 [bold green]Initialization Complete![/bold green] 🎉\n\n"
            "Your project is ready. Next steps:\n"
            "1. Initialize a new git repository (`git init`)\n"
            "2. Install dependencies (`uv pip install -e .[dev]`)\n"
            "3. Run the tests (`pytest`)",
            title="Success",
            border_style="green",
            expand=False,
        )
    )


if __name__ == "__main__":
    app()
